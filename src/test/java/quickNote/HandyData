====================================================================================
1. Polymorphism [Ability of an object to take multiple forms]
===============
Polymorphism - In Java, it allows objects of different classes to be treated as an
object of common super class thru Inheritance, Method Overloading and Overriding.

2 Types of polymorphism
=======================
1. Compile Time
2. Runtime

1. Method Overloading AKA Early Binding / Static Binding / Compile Time Polymorphism
   / Static Method Dispatch.
2. Method Overriding AKA Late Binding / Dynamic Binding / Runtime Polymorphism
   / Dynamic Method Dispatch.
3. Usage of Parent reference to hold the Child object it’s the concept of Polymorphism.
   List l = new ArrayList ();
   List l = new LinkedList ();

Note:
=====
Parent class reference can be used to hold the Child object. By using that reference
we can call only the methods available in parent class. But we can’t call child class
methods whereas using the child class reference we can call both methods.
====================================================================================
2. Method Overloading [Method Resolution takes care by Compiler]
=====================
MO - Method Overloading

Method Overloading AKA Early Binding / Static Binding / Compile Time Polymorphism
/ Static Method Dispatch.

1. Same method name with different parameters.
2. Criteria - Number of params, Type of params, Order of params. We can't overload
   only with order of params. We need different number or type of params.
3. Return Type and Access modifiers are not considered in MO.
4. VarArg method can be used in method overloading. But it takes least precedence.
5. Compiler calls the correct method with the help of number, type and
   order of params in method overloading.
6. Autoboxing and Widening is used along with method overloading. AB helps to
   convert the primitive type to its wrapper type and WD helps to convert the
   smaller data type to larger data type.
7. Compiler choose most specific /closest implementation while calling a method in
   method overloading.
8. Method Overloading works on reference type not based on the runtime object.

Notes:
======
1. Autoboxing and Unboxing may sometimes pays way for ambiguity in the MO.
2. Widening or Narrowing takes precedence over the Autoboxing and unboxing.
====================================================================================
3. Method Overriding [Method Resolution takes care by JVM]
====================

Method Overriding AKA Late Binding / Dynamic Binding / Runtime Polymorphism
/ Dynamic Method Dispatch.

1. Subclass method provides implementation for the method which is already in
   Superclass.
2. Criteria - Same method name, inheritance hierarchy, non-static methods, and
   not private methods.
3. Private and Static methods can't be overridden. Final class methods can't be
   Overridden.
4. Method Hiding involves creation of new method with same name in a subclass.
   It can be achieved with static methods.
5. Return of the overriding method can be same or covariant type [Sub type].
6. Visibility of access modifiers can be increased or maintained in same level
   but can't be decreased.
7. Checked Exception thrown by overriding method should be same as Superclass
   method or less than the Superclass method. But, overriding method can throw
   runtime exception.
8. Super Keyword can be used in Subclass overriding method to call the Superclass
   methods / members.
9. Superclass default constructor can be called automatically when the Subclass
   constructor is invoked.
10. Method Overriding works based on the runtime object rather than the reference
   type.
====================================================================================
4. Encapsulation
================
1. Encapsulation = Data Hiding + Abstraction.
    Data Hiding => Data hiding refers to the practice of making the internal state of
    an object inaccessible from outside of the object's definition.
    Abstraction => Abstraction, focuses on hiding the complex implementation details
    and showing only the essential features of an object.
2. Criteria - Private variables and Public getters and setters.
3. Integrity, Access Control and Code Organization.
4. Benefits - Data hiding, Modularity, Flexibility and Security.
5. Without Encapsulation - It leads to Data inconsistency and compromise on the
   integrity of the code.
6. Encapsulation promotes loose coupling and high cohesion.
7. Alternatives for Setters/Getters - Builder Pattern and Immutable Objects.
8. Java Reflections might have impact on Encapsulation. It access private members,
   violation of  encapsulation, and security risks.
====================================================================================
5. Inheritance
==============
1. Inheritance AKA Is-A Relationship.
2. It is a mechanism by which one class can acquire / access the properties and
   behaviours of another class.
3. Extends keyword is used to implement the inheritance relation.
4. Types - Single, Multilevel, Hierarchical and Multiple [Not supported by Class, but
   by Interface].
5. Only methods properties and methods can be inherited whereas Constructors can't be
   inherited.
6. Final classes can't be inherited. Likewise private members [fields / methods] can't
   be inherited.
7. Example - Object class in Java is a root class for all the classes in Java. It's
   methods - equals(), hashCode() and toString() is accessible all Java classes.
8. Benefits - Code reusability, Supports Polymorphism, and Easy maintenance.
9. Limitations - Tight coupling, and Potential for Fragility [ Changes made to Super
   can impact the Child].
10. Inheritance is applicable for both classes and interfaces.
====================================================================================