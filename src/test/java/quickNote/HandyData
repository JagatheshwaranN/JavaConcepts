====================================================================================
1. Polymorphism [Ability of an object to take multiple forms]
===============
Polymorphism - In Java, it allows objects of different classes to be treated as an
object of common super class thru Inheritance, Method Overloading and Overriding.

2 Types of polymorphism
=======================
1. Compile Time
2. Runtime

1. Method Overloading AKA Early Binding / Static Binding / Compile Time Polymorphism
   / Static Method Dispatch.
2. Method Overriding AKA Late Binding / Dynamic Binding / Runtime Polymorphism
   / Dynamic Method Dispatch.
3. Usage of Parent reference to hold the Child object it’s the concept of Polymorphism.
   List l = new ArrayList ();
   List l = new LinkedList ();

Note:
=====
Parent class reference can be used to hold the Child object. By using that reference
we can call only the methods available in parent class. But we can’t call child class
methods whereas using the child class reference we can call both methods.
====================================================================================
2. Method Overloading [Method Resolution takes care by Compiler]
=====================
MO - Method Overloading

Method Overloading AKA Early Binding / Static Binding / Compile Time Polymorphism
/ Static Method Dispatch.

1. Same method name with different parameters.
2. Criteria - Number of params, Type of params, Order of params. We can't overload
   only with order of params. We need different number or type of params.
3. Return Type and Access modifiers are not considered in MO.
4. VarArg method can be used in method overloading. But it takes least precedence.
5. Compiler calls the correct method with the help of number, type and
   order of params in method overloading.
6. Autoboxing and Widening is used along with method overloading. AB helps to
   convert the primitive type to its wrapper type and WD helps to convert the
   smaller data type to larger data type.
7. Compiler choose most specific /closest implementation while calling a method in
   method overloading.
8. Method Overloading works on reference type not based on the runtime object.

Notes:
======
1. Autoboxing and Unboxing may sometimes pays way for ambiguity in the MO.
2. Widening or Narrowing takes precedence over the Autoboxing and unboxing.
====================================================================================
3. Method Overriding [Method Resolution takes care by JVM]
====================

Method Overriding AKA Late Binding / Dynamic Binding / Runtime Polymorphism
/ Dynamic Method Dispatch.

1. Subclass method provides implementation for the method which is already in
   Superclass.
2. Criteria - Same method name, inheritance hierarchy, non-static methods, and
   not private methods.
3. Private and Static methods can't be overridden. Final class methods can't be
   Overridden.
4. Method Hiding involves creation of new method with same name in a subclass.
   It can be achieved with static methods.
5. Return of the overriding method can be same or covariant type [Sub type].
6. Visibility of access modifiers can be increased or maintained in same level
   but can't be decreased.
7. Checked Exception thrown by overriding method should be same as Superclass
   method or less than the Superclass method. But, overriding method can throw
   runtime exception.
8. Super Keyword can be used in Subclass overriding method to call the Superclass
   methods / members.
9. Superclass default constructor can be called automatically when the Subclass
   constructor is invoked.
10. Method Overriding works based on the runtime object rather than the reference
   type.
====================================================================================
4. Encapsulation
================
1. Encapsulation = Data Hiding + Abstraction.
    Data Hiding => Data hiding refers to the practice of making the internal state of
    an object inaccessible from outside of the object's definition.
    Abstraction => Abstraction, focuses on hiding the complex implementation details
    and showing only the essential features of an object.
2. Criteria - Private variables and Public getters and setters.
3. Integrity, Access Control and Code Organization.
4. Benefits - Data hiding, Modularity, Flexibility and Security.
5. Without Encapsulation - It leads to Data inconsistency and compromise on the
   integrity of the code.
6. Encapsulation promotes loose coupling and high cohesion.
7. Alternatives for Setters/Getters - Builder Pattern and Immutable Objects.
8. Java Reflections might have impact on Encapsulation. It access private members,
   violation of  encapsulation, and security risks.
====================================================================================
5. Inheritance
==============
1. Inheritance AKA Is-A Relationship.
2. It is a mechanism by which one class can acquire / access the properties and
   behaviours of another class.
3. Extends keyword is used to implement the inheritance relation.
4. Types - Single, Multilevel, Hierarchical and Multiple [Not supported by Class, but
   by Interface].
5. Only properties[variables] and methods can be inherited whereas Constructors can't be
   inherited.
6. Final classes can't be inherited. Likewise private members [fields / methods] can't
   be inherited.
7. Example - Object class in Java is a root class for all the classes in Java. It's
   methods - equals(), hashCode() and toString() is accessible all Java classes.
8. Benefits - Code reusability, Supports Polymorphism, and Easy maintenance.
9. Limitations - Tight coupling, and Potential for Fragility [ Changes made to Super
   can impact the Child].
10. Inheritance is applicable for both classes and interfaces.
====================================================================================
6. Abstract Class
=================
1. Abstract class is class which has methods with no implementations.It is defined
   using the abstract keyword.
2. Need - To achieve the abstraction.
3. Abstraction - It is a mechanism where abstract class defines what methods must be
   implemented by its subclasses without providing the full implementation itself.
4. Criteria - Class shouldn't be final. Methods shouldn't be private or static.
5. Objects are not created for the Abstract class as it has methods without implementations.
6. Abstract class can have constructors which is invoked by subclass.
7. Abstract methods in abstract class is used to define the interface for the subclass
   / implementation class.
8. Abstract class can have concrete methods as well.
9. If Subclass doesn't provide implementation, then it should be declared as Abstract.
10. Benefits - Code Reusability, Abstraction, Encapsulation and Polymorphism.
11. Limitations - Cannot be instantiated, Mandatory method implementation, Increased
    complexity and Less Flexibility.
====================================================================================
7. Interface
============
1. Interface is a blueprint / contract which defines set of methods that a class must
   implement. [Any service requirement specification or any contract between the client
    and service provider is called as Interface]
2. Need - To achieve the abstraction.
3. Every method declared inside interface is always public abstract.
4. Every variables declared inside interface is always public static final.
5. Interface can't have instance variables,constructors, or non-static methods.
6. Interface can't be instantiated. They can only be implemented by a class or extends
   another interface.
7. Interface can have constants, abstract methods, default methods, private methods and
   static methods.
8. Benefits - Abstraction, code reusability, Loose coupling,polymorphism, define contract.
9. Marker Interface - Interface with no method declarations. It provides the information
   about the implementation class.
   Ex: Serializable, Cloneable, and RandomAccess interfaces.
10. Functional Interface - Interface with single abstract method can be used with
    lambda or method reference.
11. Interface can extend multiple interfaces.
12. Interface used in serialization where it marks the class as serializable.
13. Adapter pattern allows incompatible interfaces to work together by providing the
    bridge between them.
====================================================================================
