====================================================================================
1. Polymorphism [Ability of an object to take multiple forms]
===============
Polymorphism - In Java, it allows objects of different classes to be treated as an
object of common super class thru Inheritance, Method Overloading and Overriding.

2 Types of polymorphism
=======================
1. Compile Time
2. Runtime

1. Method Overloading AKA Early Binding / Static Binding / Compile Time Polymorphism
   / Static Method Dispatch.
2. Method Overriding AKA Late Binding / Dynamic Binding / Runtime Polymorphism
   / Dynamic Method Dispatch.
3. Usage of Parent reference to hold the Child object it’s the concept of Polymorphism.
   List l = new ArrayList ();
   List l = new LinkedList ();

Note:
=====
Parent class reference can be used to hold the Child object. By using that reference
we can call only the methods available in parent class. But we can’t call child class
methods whereas using the child class reference we can call both methods.
====================================================================================
2. Method Overloading [Method Resolution takes care by Compiler]
=====================
MO - Method Overloading

Method Overloading AKA Early Binding / Static Binding / Compile Time Polymorphism
/ Static Method Dispatch.

1. Same method name with different parameters.
2. Criteria - Number of params, Type of params, Order of params. We can't overload
   only with order of params. We need different number or type of params.
3. Return Type and Access modifiers are not considered in MO.
4. VarArg method can be used in method overloading. But it takes least precedence.
5. Compiler calls the correct method with the help of number, type and
   order of params in method overloading.
6. Autoboxing and Widening is used along with method overloading. AB helps to
   convert the primitive type to its wrapper type and WD helps to convert the
   smaller data type to larger data type.
7. Compiler choose most specific /closest implementation while calling a method in
   method overloading.
8. Method Overloading works on reference type not based on the runtime object.

Notes:
======
1. Autoboxing and Unboxing may sometimes pays way for ambiguity in the MO.
2. Widening or Narrowing takes precedence over the Autoboxing and unboxing.
====================================================================================
3. Method Overriding [Method Resolution takes care by JVM]
====================

Method Overriding AKA Late Binding / Dynamic Binding / Runtime Polymorphism
/ Dynamic Method Dispatch.

1. Subclass method provides implementation for the method which is already in
   Superclass.
2. Criteria - Same method name, inheritance hierarchy, non-static methods, and
   not private methods.
3. Private and Static methods can't be overridden. Final class methods can't be
   Overridden.
4. Method Hiding involves creation of new method with same name in a subclass.
   It can be achieved with static methods.
5. Return of the overriding method can be same or covariant type [Sub type].
6. Visibility of access modifiers can be increased or maintained in same level
   but can't be decreased.
7. Checked Exception thrown by overriding method should be same as Superclass
   method or less than the Superclass method. But, overriding method can throw
   runtime exception.
8. Super Keyword can be used in Subclass overriding method to call the Superclass
   methods / members.
9. Superclass default constructor can be called automatically when the Subclass
   constructor is invoked.
10. Method Overriding works based on the runtime object rather than the reference
   type.
====================================================================================
4. Encapsulation
================
1. Encapsulation = Data Hiding + Abstraction.
    Data Hiding => Data hiding refers to the practice of making the internal state of
    an object inaccessible from outside of the object's definition.
    Abstraction => Abstraction, focuses on hiding the complex implementation details
    and showing only the essential features of an object.
2. Criteria - Private variables and Public getters and setters.
3. Integrity, Access Control and Code Organization.
4. Benefits - Data hiding, Modularity, Flexibility and Security.
5. Without Encapsulation - It leads to Data inconsistency and compromise on the
   integrity of the code.
6. Encapsulation promotes loose coupling and high cohesion.
7. Alternatives for Setters/Getters - Builder Pattern and Immutable Objects.
8. Java Reflections might have impact on Encapsulation. It access private members,
   violation of  encapsulation, and security risks.
====================================================================================
5. Inheritance
==============
1. Inheritance AKA Is-A Relationship.
2. It is a mechanism by which one class can acquire / access the properties and
   behaviours of another class.
3. Extends keyword is used to implement the inheritance relation.
4. Types - Single, Multilevel, Hierarchical and Multiple [Not supported by Class, but
   by Interface].
5. Only properties[variables] and methods can be inherited whereas Constructors can't be
   inherited.
6. Final classes can't be inherited. Likewise private members [fields / methods] can't
   be inherited.
7. Example - Object class in Java is a root class for all the classes in Java. It's
   methods - equals(), hashCode() and toString() is accessible all Java classes.
8. Benefits - Code reusability, Supports Polymorphism, and Easy maintenance.
9. Limitations - Tight coupling, and Potential for Fragility [ Changes made to Super
   can impact the Child].
10. Inheritance is applicable for both classes and interfaces.
====================================================================================
6. Abstract Class
=================
1. Abstract class is class which has methods with no implementations.It is defined
   using the abstract keyword.
2. Need - To achieve the abstraction.
3. Abstraction - It is a mechanism where abstract class defines what methods must be
   implemented by its subclasses without providing the full implementation itself.
4. Criteria - Class shouldn't be final. Methods shouldn't be private or static.
5. Objects are not created for the Abstract class as it has methods without implementations.
6. Abstract class can have constructors which is invoked by subclass.
7. Abstract methods in abstract class is used to define the interface for the subclass
   / implementation class.
8. Abstract class can have concrete methods as well.
9. If Subclass doesn't provide implementation, then it should be declared as Abstract.
10. Benefits - Code Reusability, Abstraction, Encapsulation and Polymorphism.
11. Limitations - Cannot be instantiated, Mandatory method implementation, Increased
    complexity and Less Flexibility.
====================================================================================
7. Interface
============
1. Interface is a blueprint / contract which defines set of methods that a class must
   implement. [Any service requirement specification or any contract between the client
    and service provider is called as Interface]
2. Need - To achieve the abstraction.
3. Every method declared inside interface is always public abstract.
4. Every variables declared inside interface is always public static final.
5. Interface can't have instance variables,constructors, or non-static methods.
6. Interface can't be instantiated. They can only be implemented by a class or extends
   another interface.
7. Interface can have constants, abstract methods, default methods, private methods and
   static methods.
8. Benefits - Abstraction, code reusability, Loose coupling, polymorphism, define contract.
9. Marker Interface - Interface with no method declarations. It provides the information
   about the implementation class.
   Ex: Serializable, Cloneable, and RandomAccess interfaces.
10. Functional Interface - Interface with single abstract method can be used with
    lambda or method reference.
11. Interface can extend multiple interfaces.
12. Interface used in serialization where it marks the class as serializable.
13. Adapter pattern allows incompatible interfaces to work together by providing the
    bridge between them.
====================================================================================
8. Composition & Aggregation [AKA HAS-A Relation]
============================
1. Composition and Aggregation provides the "Has-A" relationship between objects in Java.
2. Composition has strong relationship between classes where the parent (containing
   object) is responsible for the lifetime of the child(contained object).
3. Aggregation has weak relationship between classes where the parent (containing object)
   is not responsible for the lifetime of the child( contained object) and both can exists
   independently.
4. In composition, the contained object is often initialized inside the containing class
   constructor.
5. Benefits - Improved object lifecycle management, modular design, and encapsulation.
6. Drawback of Composition - Excessive composition can tightly couple the objects.
7. Composition is implemented using Constructor / Setter injection, whereas Aggregation
   is implemented using member variables or method parameters.
8. Composition can be used as an option in place of inheritance.
9. If we want the part of the functionality of the class then we should go for the Has
   A relationship, whereas if complete functionality is needed then we should use Is-A.
====================================================================================
9. Cohesion & Coupling
======================
1. Cohesion refers to the degree to which the elements of the module belongs together.
   It measures the bonding between the data and methods of a class.
2. Coupling refers to how tightly modules are dependent on each other. It measures the
   bonding between the modules [Classes].
3. High Cohesion can be achieved by following SRP design pattern, grouping related functions
   and data together. Using private methods for functionality that is not meant to expose.
4. Low coupling can be achieved by following Interface based programming, Dependency injection
   and using design patterns like observer pattern or factory pattern.
5. Advantages of High Cohesion and Low Coupling - Code Maintainability, Understandability,
   flexibility, testability, robustness and scalability.
6. Recommended is always High Cohesion and Low Coupling. Reverse is not advisable.
====================================================================================
10. Constructor
===============
Constructor [ Special type of Method]
1. Constructor are special type of method, which is used to initialize the Objects.
   [Instance variables] It is called / invoked implicitly when an instance of class
   is created.
2. Significance - Have same name as class name and doesn't have return type.
3. Types - Default and Parameterized.
4. Criteria - Constructor can't be final|static|abstract.
5. Constructors can be overloaded. It allows for creation of Objects in different ways.
6. Constructors can't be overridden.
7. "this()" method is used for constructor chaining which means we can call a constructor
   from another constructor using this keyword and it should be first statement in it.
8. Constructor can throw exception.
9. "super()" method is used to call the superclass constructor from the subclass constructor.
10. Private constructor are allowed and its often used in Singleton Design Pattern.
11. The only applicable modifiers for Constructors are Public, Private, Protected
    and Default.
12. If we are not having any constructor, then only compiler will generate the default
    constructor.
====================================================================================
11. Type Casting
================
1. Type casting refers to converting the data of one type to another.
   [Treating the object of one class as another class]
2. Types - UpCasting and DownCasting.
3. Criteria - Inheritance relationship is required.
4. UpCasting - Casting from a subclass to a superclass. Safe and done by compiler.
5. DownCasting - Casting from a superclass to a subclass. Risk and needs explicit
   casting by programmer. It might throw ClassCastException if object being casted
   is not instance of subclass.
6. InstanceOf operator is used to check whether the object is an instance of class/
   interface. It is used in DownCasting before performing the casting, it is used
   to check that object is instance of the class / interface.
7. Object TypeCasting is ONLY for reference data types not for primitives.
8. Converting of Integer Object to Double requires 2 steps.
   1. Integer object to int primitive using Unboxing
   2. Int primitive to Double object using AutoBoxing
9. Examples
   Superclass obj = new Subclass(); // Upcasting
   SuperClass obj1 = new SubClass();
   SubClass obj2 = (SubClass)obj1; // Down-casting
====================================================================================


